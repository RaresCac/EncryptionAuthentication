#ifndef ENCRYPTOR_H
#define ENCRYPTOR_H

#include <QObject>
#include <openssl/aes.h>

class Encryptor : public QObject
{
    Q_OBJECT
public:
    explicit Encryptor(QObject *parent = nullptr);

    void derivePassword(QString password, uchar* salt, uchar* storedPDKOut, uchar* encPDKOut);
    int encryptAES_256_CBC(uchar* input, size_t inSize, uchar* key, uchar* iv, uchar* output);
    int decryptAES_256_CBC(uchar* input, size_t inSize, uchar* key, uchar* iv, uchar* output);
    int sha256(uchar* input, size_t inSize, uchar* output, uint* outSize);

    uchar* getRandomKey(int size);
    size_t getKeySize() const;
    int getPassIterations() const;

    void setKeySize(const size_t &keySize);
    void setPassIterations(int passIterations);

signals:
    void errorOccured(int id);

private:
    bool _generateRandomBytes(uchar* array, size_t size);
    int _derivePassword(char* password, uchar* salt, size_t size, uchar* output);
    void _splitArrayHalf(uchar* input, size_t inSize, uchar* half1, uchar* half2);
    void _handleErrorMessage(int errorCode);

    //Sizes of the randomly generated bytes
    size_t _keySize = 32;
    size_t _derivedKeySize = _keySize * 2;      //Doubled since one half is used to authenticate the pass and the other to
    size_t _ivSize = AES_BLOCK_SIZE;

    int _passIterations = 100000;               //Iterations for PBKDF2_HMAC
};

#endif // ENCRYPTOR_H
